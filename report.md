# C语言代码规范
 
## 文件结构

每个C程序通常分为两个文件。一个文件用于保存程序的声明（declaration），称为头文件。另一个文件用于保存程序的实现，称为定义（definition）文件。头文件以“.h”为后缀，定义文件以“.c”为后缀。

## 版权和版本的声明

版权和版本的声明位于头文件和定义文件的开头（参见[示例1-1](**示例1-1**)），主要内容包括：

（1）版权信息。（Copyright (C)）

（2）文件名称，标识符，摘要。（File, Description）

（3）当前版本号，作者/修改者，完成日期。 (Version, Author, Date)

（4）版本历史信息。 (History)

全部内容尽量使用英文说明
```c
/******************************************************************************
 Copyright (C), 2010, Shenzhen G&T Industrial Development Co., Ltd
 File: cmd_sock.c
 Author: shumin
 Version: 1.0
 Date: 2009.03
 Description: network APIs 
 ** History:
 ** Author (core ID) Date Number Description of Changes
 **-----------------------------------------------------------------------------
 ** bjg019 30-Dec-2009 LIBtt54238 Implement +MIPCLOSE response as unsolicited 
 ** response, after socket was removed from time wait list.
 ** brz018 08-Dec-2009 LIBtt41180 Report +FTPCLOSE only after receiving CLOSE 
 ** event.
 ** ----------------------------------------------------------------------------- 
******************************************************************************/
```

**示例1-1** 版权和版本的声明

1.  **头文件的结构**

头文件由三部分内容组成：

（1）头文件开头处的版权和版本声明（参见示例1-1）。

（2）预处理块。

（3）函数和数据结构声明等。

规则:

1.2.1: 为了防止头文件被重复引用，应当用ifndef/define/endif结构产生预处理块。

1.2.2: 用 \#include \<filename.h\>
格式来引用标准库的头文件（编译器将从标准库目录开始搜索）。

1.2.3: 用 \#include “filename.h”
格式来引用非标准库的头文件（编译器将从用户的工作目录开始搜索）。

 

| // 版权和版本声明  \#ifndef   \_COMMAND_SOCKET  // 防止被重复引用 \#define   \_COMMAND_SOCKET  \#include \<math.h\>     // 引用标准库的头文件 … \#include “myheader.h”   // 引用非标准库的头文件 \#define SKCMD_CLOSE 0 // 宏定义 \#define SKCMD_CONNECT 1 … void Function1(…);   // 全局函数声明 … \#endif |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|


示例1-2 C头文件的结构

 

1.  **定义文件的结构**

定义文件有三部分内容：

（1） 定义文件开头处的版权和版本声明（参见示例1-1）。

（2） 对一些头文件的引用。

（3） 程序的实现体（包括数据和代码）。

| // 版权和版本声明见示例1-1，此处省略。  \#include “graphics.h”     // 引用头文件 … static char myselfIP[32]; // 静态变量 int gReceiveLength; // 全局变量 // 全局函数的实现体 void Function1(…) { … }  |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|


示例1-3 C文件的结构

规则:

1.3.1: 用 \#include \<filename.h\>
格式来引用标准库的头文件（编译器将从标准库目录开始搜索）。

1.3.2: 用 \#include “filename.h”
格式来引用非标准库的头文件（编译器将从用户的工作目录开始搜索）。

1.3.3: 全局和静态变量的声明统一在文件前部，引用头文件之后，以方便查找。

1.  **头文件的作用**

（1）通过头文件来调用库功能。在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制的库即可。用户只需要按照头文件中的接口声明来调用库功能，而不必关心接口怎么实现的。编译器会从库中提取相应的代码。

（2）头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误，这一简单的规则能大大减轻程序员调试、改错的负担。

1.  **目录结构**

如果一个软件的头文件数目比较多（如超过十个），通常应将头文件和定义文件分别保存于不同的目录，以便于维护。如果某些头文件是私有的，它不会被用户的程序直接引用，则没有必要公开其“声明”，这些私有的头文件可以和定义文件存放于同一个目录。

1.    
    **程序的版式**

版式虽然不会影响程序的功能，但会影响可读性。程序的版式追求清晰、美观，是程序风格的重要构成因素。（很多编辑软件具有自动排版的功能）

1.  **空行**

空行起着分隔程序段落的作用。空行得体（不过多也不过少）将使程序的布局更加清晰。

规则:

2.1.1: 在每个结构体声明之后、每个函数定义结束之后都要加空行。参见示例2-1（a）

2.1.2:
在一个函数体内，逻揖上密切相关的语句之间不加空行，其它地方应加空行分隔。参见示例2-1（b
）

2.1.2: 文件中不得存在无规则的空行，比如说连续十个空行

| // 空行 void Function1(…) {   … } // 空行 void Function2(…) {   … } // 空行 void Function3(…) {   … }  | // 空行 while (condition) {   statement1;   // 空行   if (condition)   {      statement2;   }   else   {      statement3;   } // 空行   statement4; }  |
|--------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------|


示例2-1(a) 函数之间的空行           示例2-1(b) 函数内部的空行

1.  **代码行**

规则:

2.2.1: 结构中元素布局合理，一行只定义一个元素

2.2.2:
一行代码只做一件事情，如只定义一个变量，或只写一条语句。这样的代码容易阅读，并且方便于写注释。

2.2.3:
if、for、while、do等语句自占一行，执行语句不得紧跟其后。不论执行语句有多少都要加{}，且{}单独占用一行。这样可以防止书写失误。

建议:

尽可能在定义变量的同时初始化该变量（就近原则）。如果变量的引用处和其定义处相隔比较远，变量的初始化很容易被忘记。如果引用了未被初始化的变量，可能会导致程序错误。本建议可以减少隐患。例如

int width = 10;     // 定义并初绐化width

int height = 10; // 定义并初绐化height

int depth = 10;     // 定义并初绐化depth

示例2-2（a）为风格良好的代码行，示例2-2（b）为风格不良的代码行。 

| int width;    // 宽度 int height;   // 高度 int depth;    // 深度            | int width, height, depth; // 宽度高度深度                              |
|------------------------------------------------------------------------------|------------------------------------------------------------------------|
| x = a + b; y = c + d; z = e + f;                                             | X ＝ a + b;  y = c + d; z = e + f;                                     |
| if (width \< height) { dosomething(); }                                      | if (width \< height) dosomething();                                    |
| for (initialization; condition; update) { dosomething(); } // 空行 other();  | for (initialization; condition; update)      dosomething(); other();   |

示例2-2(a) 风格良好的代码行         示例2-2(b) 风格不良的代码行

 

1.  **代码行内的空格**

规则:

2.3.1: 关键字之后要留空格。象const、virtual、inline、case
等关键字之后至少要留一个空格，否则无法辨析关键字。象if、for、while等关键字之后应留一个空格再跟左括号‘（’，以突出关键字。

2.3.2: 函数名之后不要留空格，紧跟左括号‘（’，以与关键字区别。

2.3.3: ‘（’后，‘）’、‘，’、‘;’前不留空格。

2.3.4: ‘，’之后要留空格，如Function(x, y,
z)。如果‘;’不是一行的结束符号，其后要留空格，如for (i = 1; i \< 10; ++i)。

2.3.5: 赋值操作符、比较操作符、算术操作符、逻辑操作符、位域操作符，如“=”、“+=”
“\>=”、“\<=”、“+”、“\*”、“%”、“&&”、“\|\|”、“\<\<”,“\^”等二元操作符的前后应当加空格。

2.3.6: 一元操作符如“!”、“\~”、“++”、“--”、“&”（地址运算符）等前后不加空格。

2.3.7: 象“［］”、“.”、“-\>”这类操作符前后不加空格。

建议:

对于表达式比较长的for语句和if语句，为了紧凑起见可以适当地去掉一些空格，如for
(i=0; i\<10; i++)和if ((a\<=b) && (c\<=d))

| void Func1(int x, int y, int z);          // 良好的风格 void Func1 (int x,int y,int z);           // 不良的风格                                                                                             |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| if (year \>= 2000)                   // 良好的风格 if(year\>=2000)                    // 不良的风格 if ((a\>=b) && (c\<=d))                 // 良好的风格 if(a\>=b&&c\<=d)                    // 不良的风格 |
| for (i=0; i\<10; i++)               // 良好的风格 for(i=0;i\<10;i++)                    // 不良的风格 for (i = 0; i \< 10; i ++)                // 过多的空格                                               |
| x = a \< b ? a : b;                   // 良好的风格 x=a\<b?a:b;                      // 不好的风格                                                                                                          |
| int \*x = \&y;                       // 良好的风格  int \* x = & y;                      // 不良的风格                                                                                                      |
| array[5] = 0;                  // 不要写成 array [ 5 ] = 0; a.Function();                  // 不要写成 a . Function(); b-\>Function();                 // 不要写成 b -\> Function();                        |

示例2-3 代码行内的空格

1.  **对齐**

规则:

2.4.1:
程序的分界符‘{’和‘}’应独占一行并且位于同一列，同时与引用它们的语句左对齐。

2.4.2: { }之内的代码块在‘{’右边4格处左对齐。

2.4.3: 每一个嵌套的函数块，使用一个TAB缩进（TAB设定为4个空格）。

2.4.4: \#define的各个字段对齐

示例2-4（a）为风格良好的对齐，示例2-4（b）为风格不良的对齐。

| void Function(int x) { … // program code }                              | void Function(int x){ … // program code }                      |
|-------------------------------------------------------------------------|----------------------------------------------------------------|
| if (condition) { … // program code } else { … // program code }         | if (condition){ … // program code } else { … // program code } |
| for (initialization; condition; update) { … // program code }           | for (initialization; condition; update){ … // program code }   |
| While (condition) { … // program code }                                 | while (condition){ … // program code }                         |
| 如果出现嵌套的｛｝，则使用缩进对齐，如： {    …    {       …    }   … } |                                                                |

示例2-4(a) 风格良好的对齐         示例2-4(b) 风格不良的对齐

 

1.  **长行拆分**

规则:

2.5.1:
代码行最大长度宜控制在70至80个字符以内。代码行不要过长，否则眼睛看不过来，也不便于打印。

2.5.2:
长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首（以便突出操作符）。拆分出的新行要进行适当的缩进，使排版整齐，语句可读。

 

| if ((very_longer_variable1 \>= very_longer_variable12) && (very_longer_variable3 \<= very_longer_variable14) && (very_longer_variable5 \<= very_longer_variable16)) {     dosomething(); } |
|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| virtual CMatrix CMultiplyMatrix (CMatrix leftMatrix,                                  CMatrix rightMatrix);                                                                                |
| for (very_longer_initialization;      very_longer_condition;      very_longer_update) {     dosomething(); }                                                                               |

示例2-5 长行的拆分

1.  **修饰符的位置**

规则:

2.6.1: 应当将修饰符 \* 和 ＆ 紧靠变量名

例如：

>   char  \*name;

    int   \*x, y;  // 此处y不会被误解为指针

1.  **注释**

功能性注释嵌在源程序体中，用于描述其后的语句或程序段做什么工作，也就是解释下面要做什么，或是执行了下面的语句会怎么样。注释尽量使用英文。

规则:

2.7.1:
对于所有的常量，变量，数据结构声明(包括数组、结构、类、枚举等)，如果其命名不是充分自注释的，在声明时都必须加以注释，说明其含义。

2.7.2:
注释是对代码的“提示”，而不是文档。程序中的注释不可喧宾夺主，注释太多了会让人眼花缭乱。注释的花样要少。

2.7.3: 如果代码本来就是清楚的，则不必加注释。否则多此一举，令人厌烦。例如

>   i++;     // i 加 1，多余的注释

2.7.4:
边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。

2.7.5: 注释应当准确、易懂，防止注释有二义性。错误的注释不但无益反而有害。

2.7.6: 尽量避免在注释中使用缩写，特别是不常用的缩写。

2.7.7: 注释的位置应与被描述的代码相邻，可以放在代码的上方或右方，不可放在下方。

2.7.8:
当代码比较长，特别是有多重嵌套时，应当在一些段落的结束处加注释，便于阅读。

 

| /\* \* 函数介绍： \* 输入参数： \* 输出参数： \* 返回值  ： \*/ void Function(float x, float y, float z) {   … }  | if (…) {   …   while (…)   { … } // end of while … } // end of if  |
|-------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|


>   示例2-6 程序的注释

1.    
    **命名规则**

符号名包括模块名、常量名、标号名、子程序名等。这些名字应该能反映它所代表的实际东西，具有一定的意义，使其能够见名知义，有助于对程序功能的理解。

比较著名的命名规则当推Microsoft公司的“匈牙利”法，该命名规则的主要思想是“在变量和函数名中加入前缀以增进人们对程序的理解”。linux程序也有一套命名规则。

没有一种命名规则可以让所有的程序员赞同，程序设计教科书一般都不指定命名规则。命名规则对软件产品而言并不是“成败悠关”的事。我们只是制定一种令大多数项目成员满意的命名规则，并在项目中贯彻实施。

规则:

3.1:
所有宏定义、枚举常数和const变量，用大写字母命名。在复合词里用下划线隔开每个词。

3.2: 标识符应当直观且可以拼读，可望文知意，不必进行“解码”。

标识符最好采用英文单词或其组合，便于记忆和阅读。不能使用汉语拼音来命名。程序中的英文单词一般不会太复杂，用词应当准确。例如不要把CurrentValue写成NowValue。

3.3:
名字的长度一般不要过长或过短。过长的名字会增加工作量，使程序逻辑流程变得模糊；过短的名字无法表达符号的实际意义。约定长度范围：3-31；

3.4: 循环变量尽可能采用i, j, k等单字符变量。

3.5: 命名规则尽量与所采用的操作系统或开发工具的风格保持一致。

例如Windows应用程序的标识符通常采用“大小写”混排的方式，如AddChild。而Unix应用程序的标识符通常采用“小写加下划线”的方式，如add_child。不要把不同风格混在一起用。

3.6:函数的名字应当使用“动词”或者“动词＋名词”（动宾词组）,第一个词采用全部小写，随后每个单词采用第一个字母大写，其它字母小写方式,
单词之间不用下划线。

例如： nsOnMnPlmnListResponse

3.7: 程序中不能出现仅靠大小写区分的相似的标识符。

例如：

int  x,  X;      // 变量x 与 X 容易混淆

void foo(int x);    // 函数foo 与FOO容易混淆

void FOO(float x);

3.8:
程序中不能出现标识符完全相同的局部变量和全局变量，尽管两者的作用域不同而不会发生语法错误，但会使人误解。

3.9: 变量的名字应当使用“名词”或者“形容词＋名词”。

例如：

float  value;

float  oldValue;

float  newValue;

3.10: 用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。

例如：

int      minValue;

int      maxValue;

 

int      SetValue(…);

int      GetValue(…);

建议:

尽量避免名字中出现数字编号，如Value1,Value2等，除非逻辑上的确需要编号。

1.    
    **表达式和基本语句**

    1.  **运算符的优先级**

C语言的运算符有数十个，运算符的优先级与结合律如表4-1所示。注意一元运算符 +  - 
\* 的优先级高于对应的二元运算符。

 

| 优先级                   | 运算符                                            | 结合律    |
|--------------------------|---------------------------------------------------|-----------|
| 从  高  到  低  排  列   | ( )  [ ]  -\>  .                                  | 从左至右  |
|                          | !  \~  ++  --  （类型） sizeof +  -  \*  &        | 从右至左  |
|                          | \*  /  %                                          | 从左至右  |
|                          | \+  -                                             | 从左至右  |
|                          | \<\<  \>\>                                        | 从左至右  |
|                          | \<   \<=   \>  \>=                                | 从左至右  |
|                          | ==  !=                                            | 从左至右  |
|                          | &                                                 | 从左至右  |
|                          | \^                                                | 从左至右  |
|                          | \|                                                | 从左至右  |
|                          | &&                                                | 从左至右  |
|                          | \|\|                                              | 从右至左  |
|                          | ?:                                                | 从右至左  |
|                          | =  +=  -=  \*=  /=  %=  &=  \^= \|=  \<\<=  \>\>= | 从左至右  |

表4-1 运算符的优先级与结合律

规则:

4.1.1:
如果代码行中的运算符比较多，用括号确定表达式的操作顺序，避免使用默认的优先级。

例如：

word = (high \<\< 8) \| low

if ((a \| b) && (a & c)) 

建议：

不要使用 \*=，\^=, /=等运算符。

1.  **复合表达式**

如 a = b = c =
0这样的表达式称为复合表达式。复合表达式的优点是：书写简洁，可以提高编译效率。但要防止滥用复合表达式。

规则：

4.2.1: 程序编写首先应考虑清晰性，不要刻意追求技巧性而使得程序难以理解

例如：

>   i \^= j \^= i \^= j;

4.2.2: 不要编写太复杂的复合表达式。

例如：

>   i = a \>= b && c \< d && c + f \<= g + h ;   // 复合表达式过于复杂

4.2.3: 不要有多用途的复合表达式。

例如：

>   d = (a = b + c) + r ;

该表达式既求a值又求d值。应该拆分为两个独立的语句：

>   a = b + c;

>   d = a + r;

4.2.4: 不要把程序中的复合表达式与“真正的数学表达式”混淆。

例如： 

>   if (a \< b \< c)        // a \< b \< c是数学表达式而不是程序表达式

>   并不表示      

>   if ((a\<b) && (b\<c))

>   而是成了令人费解的

>   if ( (a\<b)\<c )

1.  **if 语句**

规则:

4.3.1: 不可将布尔变量直接与TRUE、FALSE或者1、0进行比较。

根据布尔类型的语义，零值为“假”（记为FALSE），任何非零值都是“真”（记为TRUE）。TRUE的值究竟是什么并没有统一的标准。例如Visual
C++ 将TRUE定义为1，而Visual Basic则将TRUE定义为-1。

假设布尔变量名字为flag，它与零值比较的标准if语句如下：

if (flag)    // 表示flag为真

if (!flag)    // 表示flag为假

其它的用法都属于不良风格，例如：

    if (flag == TRUE)  

    if (flag == 1 )    

    if (flag == FALSE)  

    if (flag == 0)     

4.3.2: 应当将整型变量用“==”或“！=”直接与0比较。

假设整型变量的名字为value，它与零值比较的标准if语句如下：

if (value == 0)

if (value != 0)

不可模仿布尔变量的风格而写成

if (value)    // 会让人误解 value是布尔变量

if (!value)

 

4.3.3: 不可将浮点变量用“==”或“！=”与任何数字比较。

例如： 10.0 \* 0.1 == 1.0 ， 不可靠

应该设法转化成“\>=”或“\<=”形式。

假设浮点变量的名字为x，应当将  

if (x == 0.0)     // 隐含错误的比较

转化为

if ((x\>=-EPSINON) && (x\<=EPSINON))

其中EPSINON是允许的误差（即精度）。

 

4.3.4: 应当将指针变量用“==”或“！=”与NULL比较。

指针变量的零值是“空”（记为NULL）。尽管NULL的值与0相同，但是两者意义不同。假设指针变量的名字为p，它与零值比较的标准if语句如下：

        if (p == NULL)    // p与NULL显式比较，强调p是指针变量

        if (p != NULL)

不要写成

        if (p == 0)   // 容易让人误解p是整型变量

        if (p != 0)    

    或者

>   if (p)            // 容易让人误解p是布尔变量

    if (!p)           

 

4.3.5: 常数和变量比较时，尽量将常数写在前面。

如：if (NULL == p) 而不写为 if (p == NULL)。

1.  **循环语句的效率**

C循环语句中，for语句使用频率最高，while语句其次，do语句很少用。

建议:

4.4.1:
在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环放在最外层，以减少CPU跨切循环层的次数。例如示例4-4(b)的效率比示例4-4(a)的高。 

| for (row=0; row\<100; row++) { for ( col=0; col\<5; col++ ) { sum = sum + a[row][col]; } } | for (col=0; col\<5; col++ ) { for (row=0; row\<100; row++) {     sum = sum + a[row][col]; } } |
|--------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|


示例4-4(a) 低效率：长循环在最外层     示例4-4(b) 高效率：长循环在最内层

4.4.2:
如果循环体内存在逻辑判断，并且循环次数很大，宜将逻辑判断移到循环体的外面。示例4-4(c)
的程序比示例4-4(d)多执行了N-1次逻辑判断。并且由于前者老要进行逻辑判断，打断了循环“流水线”作业，使得编译器不能对循环进行优化处理，降低
了效率。如果N非常大，最好采用示例4-4(d)的写法，可以提高效率。如果N非常小，两者效率差别并不明显，采用示例4-4(c)的写法比较好，因为程序更加简洁。

 

| for (i=0; i\<N; i++) { if (condition)     DoSomething(); else     DoOtherthing(); } | if (condition) { for (i=0; i\<N; i++)     DoSomething(); } else { for (i=0; i\<N; i++) DoOtherthing(); } |
|-------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------|


表4-4(c) 效率低但程序简洁          表4-4(d) 效率高但程序不简洁

1.  **for 语句的循环控制变量**

规则:

4.5.1: 不可在for 循环体内修改循环变量，防止for 循环失去控制。

建议:

建议for语句的循环控制变量的取值采用“半开半闭区间”写法。

示例4-5(a)中的x值属于半开半闭区间“0 =\< x \<
N”，起点到终点的间隔为N，循环次数为N。

示例4-5(b)中的x值属于闭区间“0 =\< x \<=
N-1”，起点到终点的间隔为N-1，循环次数为N。

相比之下，示例4-5(a)的写法更加直观，尽管两者的功能是相同的。 

| for (int x=0; x\<N; x++) { … } | for (int x=0; x\<=N-1; x++) { … } |
|--------------------------------|-----------------------------------|


示例4-5(a) 循环变量属于半开半闭区间    示例4-5(b) 循环变量属于闭区间

1.  **switch语句**

规则:

4.6.1:
每个case语句的结尾不要忘了加break，否则将导致多个分支重叠（除非有意使多个分支重叠）。

4.6.2:
不要忘记最后那个default分支。即使程序真的不需要default处理，也应该保留语句   
default : break; 这样做并非多此一举，而是为了防止别人误以为你忘了default处理。

1.  **goto语句**

自从提倡结构化设计以来，就不建议使用goto语句了。

应当少用、慎用goto语句，而不是禁用。

 

1.    
    **常量**

常量是一种标识符，它的值在运行期间恒定不变。C语言用
\#define来定义常量（称为宏常量）。

如果不使用常量，直接在程序中填写数字或字符串，将会导致：

（1）
程序的可读性（可理解性）变差。程序员自己会忘记那些数字或字符串是什么意思，用户则更加不知它们从何处来、表示什么。

（2） 在程序的很多地方输入同样的数字或字符串，难保不发生书写错误。

（3） 如果要修改数字或字符串，则会在很多地方改动，既麻烦又容易出错。

规则：

5.1: 尽量使用含义直观的常量来表示那些将在程序中多次出现的数字或字符串。

例如：

    \#define            MAX   100     /\*  C语言的宏常量  \*/

5.2:
需要对外公开的常量放在头文件中，不需要对外公开的常量放在定义文件的头部。为便于管理，可以把不同模块的常量集中存放在一个公共的头文件中。

5.3:
如果某一常量与其它常量密切相关，应在定义中包含这种关系，而不应给出一些孤立的值。

例如：

\#define RADIUS 100

\#define DIAMETER RADIUS \* 2

5.4: 常量定义（DEFINE）应该有相应说明

1.    
    **函数设计**

函数注释通常置于每函数或过程的开头部分，它应当给出函数或过程的整体说明对于理解程序本身具有引导作用。一般包括如下条目:

——模块标题。

——有关本模块功能和目的的说明。

——调用格式

——接口说明：包括输入、输出、返回值、异常。

——算法。如果模块中采用了一些复杂的算法。

例：

file://（注释开头应和上一函数空两行）

（注释开头与上一函数最后一行间隔两行）

/\*\* GPRS Show PDP Address handler.

\* Called on a CGPADDR=[...] command.

\* \@param pGprs Pointer to GPRS controller instance data

\* \@param pMssg Pointer to CGPADDR message

\* \@return ATC status

\*/

函数接口的两个要素是参数和返回值。C语言中，函数的参数和返回值的传递方式有两种：值传递（pass
by value）和指针传递（pass by pointer）。

1.  **参数的规则**

规则:

6.1.1:
参数的书写要完整，不要贪图省事只写参数的类型而省略参数名字。如果函数没有参数，则用void填充。

例如：

void SetValue(int width, int height);   // 良好的风格

void SetValue(int, int);            // 不良的风格

float GetValue(void);    // 良好的风格

float GetValue();       // 不良的风格

6.1.2: 参数命名要恰当，顺序要合理。

例如编写字符串拷贝函数StringCopy，它有两个参数。如果把参数名字起为str1和str2，例如

void StringCopy(char \*str1, char \*str2);

那么我们很难搞清楚究竟是把str1拷贝到str2中，还是刚好倒过来。

可以把参数名字起得更有意义，如叫strSource和strDestination。这样从名字上就可以看出应该把strSource拷贝到strDestination。

还有一个问题，这两个参数那一个该在前那一个该在后？参数的顺序要遵循程序员的习惯。一般地，应将目的参数放在前面，源参数放在后面。

如果将函数声明为：

void StringCopy(char \*strSource, char \*strDestination);

别人在使用时可能会不假思索地写成如下形式：

char str[20];

StringCopy(str, “Hello World”);   // 参数顺序颠倒

6.1.3:
如果参数是指针，且仅作输入用，则应在类型前加const，以防止该指针在函数体内被意外修改。

例如：

void StringCopy(char \*strDestination，const char \*strSource);

6.1.4: 不要传递数据量很大的结构体数据，应改为结构体指针传递。

建议：

避免函数有太多的参数，参数个数尽量控制在5个以内。如果参数太多，在使用时容易将参数类型或顺序搞错。

1.  **返回值的规则**

规则:

6.2.1: 不要省略返回值的类型。

C语言中，凡不加类型说明的函数，一律自动按整型处理。这样做不会有什么好处，却容易被误解为void类型。如果函数没有返回值，那么应声明为void类型。

6.2.2: 函数名字与返回值类型在语义上不可冲突。

违反这条规则的典型代表是C标准库函数getchar。

例如：

char c;

c = getchar();

if (c == EOF)

…

按照getchar名字的意思，将变量c声明为char类型是很自然的事情。但不幸的是getchar的确不是char类型，而是int类型，其原型如下：

        int getchar(void);

6.2.3:
不要将正常值和错误标志混在一起返回。正常值用输出参数获得，而错误标志用return语句返回。

建议:

有时候函数原本不需要返回值，但为了增加灵活性如支持链式表达，可以附加返回值。

例如字符串拷贝函数strcpy的原型：

char \*strcpy(char \*strDest，const char \*strSrc);

strcpy函数将strSrc拷贝至输出参数strDest中，同时函数的返回值又是strDest。这样做并非多此一举，可以获得如下灵活性：

    char str[20];

    int  length = strlen( strcpy(str, “Hello World”) );

1.  **函数内部实现的规则**

不同功能的函数其内部实现各不相同，看起来似乎无法就“内部实现”达成一致的观点。但根据经验，我们可以在函数体的“入口处”和“出口处”从严把关，从而提高函数的质量。

规则:

6.3.1: 在函数体的“入口处”，对参数的有效性进行检查。

很多程序错误是由非法参数引起的，我们应该充分理解并正确使用“断言”（assert）来防止此类错误。

6.3.2: 在函数体的“出口处”，对return语句的正确性和效率进行检查。

如果函数有返回值，那么函数的“出口处”是return语句。我们不要轻视return语句。如果return语句写得不好，函数要么出错，要么效率低下。

注意事项如下：

（1）return语句不可返回指向“栈内存”的“指针”，因为该内存在函数体结束时被自动销毁。例如

    char \* Func(void)

    {

        char str[] = “hello world”;    // str的内存位于栈上

        …

        return str;     // 将导致错误

    }

（2）要搞清楚返回的究竟是“值”还是“指针”。

1.  **其它建议**

6.4.1: 函数只有一个出口

6.4.2:
较大的局部变量应声明成静态类型(static)或者采用动态内存分配，避免占用太多的堆栈空间

6.4.3:
函数的功能要单一，不要设计多用途的函数。每个函数完成单一的功能，不设计多用途面面俱到的函数

6.4.4: 函数体的规模要小，尽量控制在100行代码之内，以便于调试和理解。

6.4.5: 尽量避免函数带有“记忆”功能。相同的输入应当产生相同的输出。

带有“记忆”功能的函数，其行为可能是不可预测的，因为它的行为可能取决于某种“记忆状态”。这样的函数既不易理解又不利于测试和维护。在C语言中，函数的static局部变量是函数的“记忆”存储器。建议尽量少用static局部变量，除非必需。

6.4.6:
不仅要检查输入参数的有效性，还要检查通过其它途径进入函数体内的变量的有效性，例如全局变量、文件句柄等。

6.4.7: 用于出错处理的返回值一定要清楚，让使用者不容易忽视或误解错误情况。

1.  **使用断言（assert）**

程序一般分为Debug版本和Release版本，Debug版本用于内部调试，Release版本发行给用户使用。

断言assert是仅在Debug版本起作用的宏，它用于检查“不应该”发生的情况。

assert不是一个仓促拼凑起来的宏。为了不在程序的Debug版本和Release版本引起差别，assert不应该产生任何副作用。所以assert不是函数，而是宏。程序员可以把assert看成一个在任何系统状态下都可以安全使用的无害测试手段。如果程序在assert处终止了，并不是说含有该assert的函数有错误，而是调用者出了差错，assert可以帮助我们找到发生错误的原因。

规则:

6.5.1:
使用断言捕捉不应该发生的非法情况。不要混淆非法情况与错误情况之间的区别，后者是必然存在的并且是一定要作出处理的。

6.5.2: 在函数的入口处，使用断言检查参数的有效性（合法性）。

1.    
    **内存管理**

    1.  **内存分配方式**

内存分配方式有三种：

（1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。

（2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

（3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc申请任意多少的内存，程序员自己负责在何时用free释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。

1.  **常见的内存错误及其对策**

发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。有时用户怒气冲冲地把你找来，程序却没有发生任何问题，你一走，错误又发作了。

常见的内存错误及其对策如下：

(1) 内存分配未成功，却使用了它。

常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc来申请内存，应该用if(p==NULL)
或if(p!=NULL)进行防错处理。

(2) 内存分配虽然成功，但是尚未初始化就引用它。

犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。

内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。

(3) 内存分配成功并且已经初始化，但操作越过了内存的边界。

例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。

(4) 忘记了释放内存，造成内存泄露。

含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。

动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误。

(5) 释放了内存却继续使用它。

规则:

7.2.1:
用malloc申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。

7.2.2: 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。

7.2.3: 避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。

7.2.4: 动态内存的申请与释放必须配对，防止内存泄漏。

7.2.5: 用free释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。

1.  **指针与数组的对比**

C程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为两者是等价的。

数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。

指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险，使用指针要特别小心。

1.  **杜绝“野指针”**

“野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。

“野指针”的成因主要有几种：

（1）
指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。例如

    char \*p = NULL;

    char \*str = (char \*) malloc(100);

（2） 指针p被free之后，没有置为NULL，让人误以为p是个合法的指针。 

（3） 指针操作超越了变量的作用范围。居然没有出错，这可能与编译器有关。

1.    
    **代码编译**

规则:

8.1: 打开编译器的所有告警开关对程序进行编译。防止隐藏可能是错误的告警。

8.2: 在同一项目组或产品组中，要统一编译开关选项。

8.3:
不要忽略编译警告。某些语句经编译后产生告警，但如果你认为它是正确的，那么应通过某种手段消除掉该警告。

附录A: 代码检查内容

| **文件结构**         |                                                                                                    |      |
|----------------------|----------------------------------------------------------------------------------------------------|------|
| 重要性               | 审查项                                                                                             | 结论 |
|                      | 头文件和定义文件的名称是否合理？                                                                   |      |
|                      | 头文件和定义文件的目录结构是否合理？                                                               |      |
|                      | 版权和版本声明是否完整？                                                                           |      |
| 重要                 | 头文件是否使用了 ifndef/define/endif 预处理块?                                                     |      |
|                      | 头文件中是否只存放“声明”而不存放“定义”                                                             |      |
|                      |                                                                                                    |      |
| **程序的版式**       |                                                                                                    |      |
| 重要性               | 审查项                                                                                             | 结论 |
|                      | 空行是否得体？                                                                                     |      |
|                      | 代码行内的空格是否得体？                                                                           |      |
|                      | 长行拆分是否得体？                                                                                 |      |
|                      | “{” 和 “}” 是否各占一行并且对齐于同一列？                                                          |      |
| 重要                 | 一行代码是否只做一件事？如只定义一个变量，只写一条语句。                                           |      |
| 重要                 | If、for、while、do等语句自占一行，不论执行语句多少都要加“{}”。                                     |      |
| 重要                 | 在定义变量（或参数）时，是否将修饰符 \* 和 ＆ 紧靠变量名？                                         |      |
|                      | 注释是否清晰并且必要？                                                                             |      |
| 重要                 | 注释是否有错误或者可能导致误解？                                                                   |      |
|                      | ……                                                                                                 |      |
| **命名规则**         |                                                                                                    |      |
| 重要性               | 审查项                                                                                             | 结论 |
| 重要                 | 命名规则是否与所采用的操作系统或开发工具的风格保持一致？                                           |      |
|                      | 标识符是否直观且可以拼读？                                                                         |      |
|                      | 标识符的长度应当符合“min-length && max-information”原则？                                          |      |
| 重要                 | 程序中是否出现相同的局部变量和全部变量？                                                           |      |
|                      | 函数名、变量和参数、常量的书写格式是否遵循一定的规则？                                             |      |
|                      | 静态变量、全局变量、是否加前缀？                                                                   |      |
|                      | ……                                                                                                 |      |
| **表达式与基本语句** |                                                                                                    |      |
| 重要性               | 审查项                                                                                             | 结论 |
| 重要                 | 如果代码行中的运算符比较多，是否已经用括号清楚地确定表达式的操作顺序？                             |      |
|                      | 是否编写太复杂或者多用途的复合表达式？                                                             |      |
| 重要                 | 是否将复合表达式与“真正的数学表达式”混淆？                                                         |      |
| 重要                 | if语句的表达式是否合理                                                                             |      |
|                      | 如果循环体内存在逻辑判断，并且循环次数很大，是否已经将逻辑判断移到循环体的外面？                   |      |
| 重要                 | Case语句的结尾是否忘了加break？                                                                    |      |
| 重要                 | 是否忘记写switch的default分支？                                                                    |      |
| 重要                 | 使用goto 语句时是否留下隐患?                                                                       |      |
|                      | ……                                                                                                 |      |
| **常量**             |                                                                                                    |      |
| 重要性               | 审查项                                                                                             | 结论 |
|                      | 是否使用含义直观的常量来表示那些将在程序中多次出现的数字或字符串？                                 |      |
| 重要                 | 如果某一常量与其它常量密切相关，是否在定义中包含了这种关系？                                       |      |
|                      | ……                                                                                                 |      |
| **函数设计**         |                                                                                                    |      |
| 重要性               | 审查项                                                                                             | 结论 |
|                      | 参数的书写是否完整？不要贪图省事只写参数的类型而省略参数名字。                                     |      |
|                      | 参数命名、顺序是否合理？                                                                           |      |
|                      | 参数的个数是否太多？                                                                               |      |
|                      | 是否省略了函数返回值的类型？                                                                       |      |
| 重要                 | 是否将正常值和错误标志混在一起返回？正常值应当用输出参数获得，而错误标志用return语句返回。         |      |
| 重要                 | 在函数体的“入口处”，是否用assert对参数的有效性进行检查？                                           |      |
| 重要                 | return语句是否返回指向“栈内存”的“指针”？                                                           |      |
|                      | ……                                                                                                 |      |
| **内存管理**         |                                                                                                    |      |
| 重要性               | 审查项                                                                                             | 结论 |
| 重要                 | 用malloc申请内存之后，是否立即检查指针值是否为NULL？（防止使用指针值为NULL的内存）                 |      |
| 重要                 | 是否忘记为数组和动态内存赋初值？（防止将未被初始化的内存作为右值使用）                             |      |
| 重要                 | 数组或指针的下标是否越界？                                                                         |      |
| 重要                 | 动态内存的申请与释放是否配对？（防止内存泄漏）                                                     |      |
| 重要                 | 是否有效地处理了“内存耗尽”问题？                                                                   |      |
| 重要                 | 是否修改“指向常量的指针”的内容？                                                                   |      |
| 重要                 | 是否出现野指针？例如 （1）指针变量没有被初始化。 （2）用free释放了内存之后，忘记将指针设置为NULL。 |      |
| 重要                 | malloc语句是否正确无误？例如字节数是否正确？类型转换是否正确？                                     |      |
|                      | ……                                                                                                 |      |

 
